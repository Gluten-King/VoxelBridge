#version 450

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

layout(binding = COLOUR_IN_BINDING) uniform sampler2D colourTexIn;
layout(binding = DEPTH_IN_BINDING) uniform sampler2D depthTexIn;
layout(binding = STENCIL_IN_BINDING) uniform usampler2D stencilTexIn;
layout(binding = BUFFER_OUT_BINDING, std430) writeonly restrict buffer OutBuffer {
    uvec2[] outBuffer;
};

void main() {
    const uint tilesX = (WIDTH + LOCAL_SIZE_X - 1u) / LOCAL_SIZE_X;
    const uint tilesY = (HEIGHT + LOCAL_SIZE_Y - 1u) / LOCAL_SIZE_Y;
    uint tileX = gl_WorkGroupID.x % tilesX;
    uint tileY = gl_WorkGroupID.y % tilesY;
    uint faceX = gl_WorkGroupID.x / tilesX;
    uint faceY = gl_WorkGroupID.y / tilesY;
    if (faceX >= 3u || faceY >= 2u) {
        return;
    }

    uint localX = tileX * LOCAL_SIZE_X + gl_LocalInvocationID.x;
    uint localY = tileY * LOCAL_SIZE_Y + gl_LocalInvocationID.y;
    if (localX >= WIDTH || localY >= HEIGHT) {
        return;
    }

    uint localOutIndex = localX + localY * WIDTH;
    uint groupOutIndex = (faceX + faceY * 3u) * (WIDTH * HEIGHT);
    uint globalOutIndex = groupOutIndex + localOutIndex;

    ivec2 samplePoint = ivec2(int(faceX * WIDTH + localX), int(faceY * HEIGHT + localY));

    uvec2 outPoint = uvec2(0);

    uvec4 colour = clamp(uvec4(texelFetch(colourTexIn, samplePoint, 0) * 255), uvec4(0), uvec4(255));
    colour <<= uvec4(0, 8, 16, 24);
    outPoint.x = colour.r | colour.g | colour.b | colour.a;

    float depth = clamp(texelFetch(depthTexIn, samplePoint, 0).r, 0, 1);
    uint stencil = texelFetch(stencilTexIn, samplePoint, 0).r;
    uint value = uint(depth * ((1 << 24) - 1)) << 8;
    value |= stencil & 0xFFu;
    outPoint.y = value;

    outBuffer[globalOutIndex] = outPoint;
}
